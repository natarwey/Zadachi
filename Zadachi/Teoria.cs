using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Zadachi
{
    //Абстракция.Моделирование требуемых атрибутов и взаимодействий сущностей в виде классов для определения абстрактного представления системы.
    //Инкапсуляция.Скрытие внутреннего состояния и функций объекта и предоставление доступа только через открытый набор функций.
    //Наследование.Возможность создания новых абстракций на основе существующих.
    //Полиморфизм.Возможность реализации наследуемых свойств или методов отличающимися способами в рамках множества абстракций.


    //Списки отличаются от массивов тем, что доступ к их элементам осуществляется последовательно, в то время
    //как массивы – структура данных произвольного доступа (предоставляет возможность в любой момент времени
    //обратиться к любому элементу по его индексу).


    //Функция - подпрограмма, выполняющая какие-либо операции и возвращающая значение.
    //Процедура - подпрограмма, которая только выполняет операции, без возврата значения.
    //Метод - это функция или процедура, которая принадлежит классу или экземпляру класса.


    //Рекурсивная функция представляет такую конструкцию, при которой функция вызывает саму себя.
    int Factorial(int n)
    {
         if (n == 1) return 1;
 
         return n * Factorial(n - 1);
    }
     int factorial4 = Factorial(4);  // 24
     Console.WriteLine($"Факториал числа 4 = {factorial4}");
 
    int Fibonachi(int n)
    {
        if (n == 0 || n == 1) return n;

        return Fibonachi(n - 1) + Fibonachi(n - 2);
    }
    int fib4 = Fibonachi(4);
    Console.WriteLine($"4 число Фибоначчи = {fib4}");

    
     //Обобщения в C# — это техника написания кода для класса без указания типа (ов) данных, с которыми работает класс.
     //Тип данных указывается при объявлении экземпляра универсального класса.Это позволяет специализировать
     //универсальный класс для множества различных типов данных, при этом писать класс нужно только один раз.

     //В C#, ключевое слово ref используется для передачи параметров по ссылке, а не по значению. Это означает, что
     //любые изменения, которые происходят с параметром внутри функции, будут отражаться на исходном элементе,
     //переданном в функцию.
    public static void Main(string[] args)
    {
        int x = 1, y = 5;
        Console.WriteLine($"x = {x}\t y = {y}");

        Swap(ref x, ref y);
        Console.WriteLine($"x = {x}\t y = {y}");
    }

    void Swap<TAny>(ref TAny x, ref TAny y) 
    {
        TAny temp = x; 
        x = y;
        y = temp;
    }
}
